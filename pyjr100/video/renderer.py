"""VRAM to pixel buffer renderer for the JR-100 display."""

from __future__ import annotations

from dataclasses import dataclass
from typing import Iterable, Tuple

from .font import FONT_HEIGHT, FONT_WIDTH, FontSet
from .font_manager import FontManager
from .palette import MONOCHROME, RGBColor, validate_palette

VRAM_WIDTH = 32
VRAM_HEIGHT = 24


@dataclass
class RenderResult:
    """Stores the RGB pixel buffer generated by the renderer."""

    width: int
    height: int
    scale: int
    pixels: bytearray

    def get_pixel(self, x: int, y: int) -> Tuple[int, int, int]:
        if not (0 <= x < self.width and 0 <= y < self.height):
            raise IndexError("pixel outside image bounds")
        index = (y * self.width + x) * 3
        return (
            self.pixels[index],
            self.pixels[index + 1],
            self.pixels[index + 2],
        )

    def to_surface(self):  # pragma: no cover - requires pygame
        try:
            import pygame  # type: ignore
        except Exception as exc:  # pragma: no cover - optional dependency
            raise RuntimeError("pygame is not available") from exc
        if pygame is None:  # type: ignore
            raise RuntimeError("pygame is not available")
        surface = pygame.image.frombuffer(self.pixels, (self.width, self.height), "RGB")
        return surface


class Renderer:
    """Converts VRAM bytes into an RGB pixel buffer."""

    def __init__(self, font: FontSet, palette=MONOCHROME, font_manager: FontManager | None = None) -> None:
        self.font = font
        self.palette = validate_palette(palette)
        self._buffer: bytearray | None = None
        self._prev_vram: bytearray | None = None
        self._prev_scale: int | None = None
        self._prev_plane: int | None = None
        self._prev_user_ram: bytes | None = None
        self._font_manager = font_manager
        self._font_revision: int | None = None

    def render(
        self,
        vram: bytes,
        *,
        user_ram: bytes | None = None,
        plane: int = 0,
        scale: int = 1,
    ) -> RenderResult:
        if len(vram) < VRAM_WIDTH * VRAM_HEIGHT:
            raise ValueError("VRAM buffer too small")
        if scale <= 0:
            raise ValueError("scale must be positive")

        width = VRAM_WIDTH * FONT_WIDTH * scale
        height = VRAM_HEIGHT * FONT_HEIGHT * scale
        cells = VRAM_WIDTH * VRAM_HEIGHT

        full_refresh = False
        buffer = self._buffer
        if buffer is None or self._prev_scale != scale:
            buffer = bytearray(width * height * 3)
            self._buffer = buffer
            self._prev_vram = bytearray(cells)
            self._prev_scale = scale
            full_refresh = True

        assert buffer is not None  # for type checkers
        prev_vram = self._prev_vram
        if prev_vram is None or len(prev_vram) != cells:
            prev_vram = bytearray(cells)
            self._prev_vram = prev_vram
            full_refresh = True

        current_user_ram = bytes(user_ram) if user_ram is not None else None
        current_font_revision = self._font_manager.revision if self._font_manager is not None else None
        if self._prev_plane != plane:
            full_refresh = True
        if current_user_ram != self._prev_user_ram and plane == 1:
            full_refresh = True
        if plane == 1 and current_font_revision != self._font_revision:
            full_refresh = True

        if full_refresh:
            prev_vram[:cells] = vram[:cells]
            self._render_full(
                buffer,
                width,
                vram,
                user_ram,
                plane,
                scale,
            )
        else:
            dirty: list[int] = []
            for index in range(cells):
                value = vram[index]
                if prev_vram[index] != value:
                    prev_vram[index] = value
                    dirty.append(index)
            if dirty:
                self._render_cells(
                    buffer,
                    width,
                    dirty,
                    vram,
                    user_ram,
                    plane,
                    scale,
                )

        self._prev_plane = plane
        self._prev_user_ram = current_user_ram
        self._font_revision = current_font_revision

        return RenderResult(width=width, height=height, scale=scale, pixels=buffer)

    def _render_full(
        self,
        pixels: bytearray,
        stride: int,
        vram: bytes,
        user_ram: bytes | None,
        plane: int,
        scale: int,
    ) -> None:
        for index in range(VRAM_WIDTH * VRAM_HEIGHT):
            col = index % VRAM_WIDTH
            row = index // VRAM_WIDTH
            value = vram[index]
            self._render_cell(pixels, stride, col, row, value, user_ram, plane, scale)

    def _render_cells(
        self,
        pixels: bytearray,
        stride: int,
        dirty: Iterable[int],
        vram: bytes,
        user_ram: bytes | None,
        plane: int,
        scale: int,
    ) -> None:
        for index in dirty:
            col = index % VRAM_WIDTH
            row = index // VRAM_WIDTH
            value = vram[index]
            self._render_cell(pixels, stride, col, row, value, user_ram, plane, scale)

    def _render_cell(
        self,
        pixels: bytearray,
        stride: int,
        col: int,
        row: int,
        value: int,
        user_ram: bytes | None,
        plane: int,
        scale: int,
    ) -> None:
        glyph = self.font.get_glyph(
            value,
            user_ram=user_ram,
            plane=plane,
            font_manager=self._font_manager,
        )
        inverted = plane == 0 and (value & 0x80) != 0
        self._blit_glyph(
            pixels,
            stride,
            col,
            row,
            glyph,
            inverted=inverted,
            scale=scale,
        )

    def _blit_glyph(
        self,
        pixels: bytearray,
        stride: int,
        col: int,
        row: int,
        glyph: Iterable[int],
        *,
        inverted: bool,
        scale: int,
    ) -> None:
        fg_r, fg_g, fg_b = self.palette[1]
        bg_r, bg_g, bg_b = self.palette[0]
        pixel_stride = stride * 3
        base_x = col * FONT_WIDTH * scale
        base_y = row * FONT_HEIGHT * scale

        for gy, raw_line in enumerate(glyph):
            line_value = raw_line & 0xFF
            if inverted:
                line_value ^= 0xFF
            dest_y = base_y + gy * scale
            for sy in range(scale):
                offset = (dest_y + sy) * pixel_stride + base_x * 3
                pos = offset
                mask = 0x80
                for _ in range(FONT_WIDTH):
                    if line_value & mask:
                        color_r, color_g, color_b = fg_r, fg_g, fg_b
                    else:
                        color_r, color_g, color_b = bg_r, bg_g, bg_b
                    for _ in range(scale):
                        pixels[pos] = color_r
                        pixels[pos + 1] = color_g
                        pixels[pos + 2] = color_b
                        pos += 3
                    mask >>= 1
