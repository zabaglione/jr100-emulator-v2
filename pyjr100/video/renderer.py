"""VRAM to pixel buffer renderer for the JR-100 display."""

from __future__ import annotations

from dataclasses import dataclass
from typing import Tuple

from .font import FONT_HEIGHT, FONT_WIDTH, FontSet
from .palette import MONOCHROME, RGBColor, validate_palette

VRAM_WIDTH = 32
VRAM_HEIGHT = 24


@dataclass
class RenderResult:
    """Stores the RGB pixel buffer generated by the renderer."""

    width: int
    height: int
    scale: int
    pixels: bytearray

    def get_pixel(self, x: int, y: int) -> Tuple[int, int, int]:
        if not (0 <= x < self.width and 0 <= y < self.height):
            raise IndexError("pixel outside image bounds")
        index = (y * self.width + x) * 3
        return (
            self.pixels[index],
            self.pixels[index + 1],
            self.pixels[index + 2],
        )

    def to_surface(self):  # pragma: no cover - requires pygame
        try:
            import pygame  # type: ignore
        except Exception as exc:  # pragma: no cover - optional dependency
            raise RuntimeError("pygame is not available") from exc
        if pygame is None:  # type: ignore
            raise RuntimeError("pygame is not available")
        surface = pygame.image.frombuffer(self.pixels, (self.width, self.height), "RGB")
        return surface


class Renderer:
    """Converts VRAM bytes into an RGB pixel buffer."""

    def __init__(self, font: FontSet, palette=MONOCHROME) -> None:
        self.font = font
        self.palette = validate_palette(palette)

    def render(
        self,
        vram: bytes,
        *,
        user_ram: bytes | None = None,
        plane: int = 0,
        scale: int = 1,
    ) -> RenderResult:
        if len(vram) < VRAM_WIDTH * VRAM_HEIGHT:
            raise ValueError("VRAM buffer too small")
        if scale <= 0:
            raise ValueError("scale must be positive")

        width = VRAM_WIDTH * FONT_WIDTH * scale
        height = VRAM_HEIGHT * FONT_HEIGHT * scale
        pixels = bytearray(width * height * 3)

        for row in range(VRAM_HEIGHT):
            for col in range(VRAM_WIDTH):
                value = vram[row * VRAM_WIDTH + col]
                glyph = self.font.get_glyph(value & 0x7F, user_ram=user_ram, plane=plane)
                inverted = (value & 0x80) != 0
                self._blit_glyph(
                    pixels,
                    width,
                    col,
                    row,
                    glyph,
                    inverted=inverted,
                    scale=scale,
                )

        return RenderResult(width=width, height=height, scale=scale, pixels=pixels)

    def _blit_glyph(
        self,
        pixels: bytearray,
        stride: int,
        col: int,
        row: int,
        glyph: bytes | Tuple[int, ...],
        *,
        inverted: bool,
        scale: int,
    ) -> None:
        fg = self.palette[1]
        bg = self.palette[0]

        for gy, line in enumerate(glyph):
            line_value = line
            if inverted:
                line_value ^= 0xFF
            for gx in range(FONT_WIDTH):
                mask = 1 << (7 - gx)
                color = fg if line_value & mask else bg
                self._write_scaled_pixel(
                    pixels,
                    stride,
                    col * FONT_WIDTH + gx,
                    row * FONT_HEIGHT + gy,
                    color,
                    scale,
                )

    def _write_scaled_pixel(
        self,
        pixels: bytearray,
        stride: int,
        x: int,
        y: int,
        color: RGBColor,
        scale: int,
    ) -> None:
        r, g, b = color
        for dy in range(scale):
            row_index = (y * scale + dy) * stride
            for dx in range(scale):
                pixel_index = ((x * scale + dx) + row_index) * 3
                pixels[pixel_index : pixel_index + 3] = bytes((r, g, b))
